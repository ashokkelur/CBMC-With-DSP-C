<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Model checking of multicore software using CBMC</TITLE>
<META NAME="description" CONTENT="Model checking of multicore software using CBMC">
<META NAME="keywords" CONTENT="report">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="report.css">

</HEAD>

<BODY >

<P>
[pages=1]title.pdf
[pages=1]blank.pdf

<P>

<P>
[pages=1]abstract.pdf
[pages=1]blank.pdf

<P>

<P>

<DIV ALIGN="CENTER">

</DIV>
<H1><A NAME="SECTION00010000000000000000">
Acknowledgements</A>
</H1>

<P>
This is a master thesis submitted in partial fulfilment of the requirements for degree of Masters of Science in Embedded Systems to Department of Information Technology, Uppsala University, Uppsala, Sweden.

<P>
I would like to thank Dr. Philipp R&#252;mmer, Thomas Magnsson and Kenneth Andersson for initiating the work, supporting continuously and providing key insights.

<P>
I would like to thank Prof. Parosh Abdulla for reviewing my master thesis.

<P>
I express my gratitude to Prof. Daniel Kr&#246;ening for helping me understand and providing updates of CBMC. 

<P>
Special thanks to Therese Breinordh and Mats Svensson for taking care of all the administrative formalities at Ericsson.

<P>
I would like to thank Uppsala University and Ericsson for providing me all the software and hardware necessary for project.

<P>
Sincere thanks to my friends and my family who gave me courage and support throughout the thesis work.

<P>
<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><UL>
<LI><A NAME="tex2html82"
  HREF="report.html#SECTION00010000000000000000">Acknowledgements</A>
</UL><BR>
<LI><A NAME="tex2html83"
  HREF="report.html#SECTION00200000000000000000">List of Figures</A>
<LI><A NAME="tex2html84"
  HREF="report.html#SECTION00300000000000000000">List of Tables</A>
<UL>
<LI><A NAME="tex2html85"
  HREF="report.html#SECTION00310000000000000000">Formal notations</A>
</UL><BR>
<LI><A NAME="tex2html86"
  HREF="report.html#SECTION00400000000000000000">Introduction</A>
<UL>
<LI><A NAME="tex2html87"
  HREF="report.html#SECTION00401000000000000000">Contributions</A>
<LI><A NAME="tex2html88"
  HREF="report.html#SECTION00402000000000000000">Structure of the thesis report</A>
</UL><BR>
<LI><A NAME="tex2html89"
  HREF="report.html#SECTION00500000000000000000">Background</A>
<UL>
<LI><A NAME="tex2html90"
  HREF="report.html#SECTION00510000000000000000">DSP-C</A>
<UL>
<LI><A NAME="tex2html91"
  HREF="report.html#SECTION00511000000000000000">Fixed point</A>
<LI><A NAME="tex2html92"
  HREF="report.html#SECTION00512000000000000000">Fixed point data type</A>
<LI><A NAME="tex2html93"
  HREF="report.html#SECTION00513000000000000000">Divided memory spaces</A>
<LI><A NAME="tex2html94"
  HREF="report.html#SECTION00514000000000000000">Dedicated register sets</A>
<LI><A NAME="tex2html95"
  HREF="report.html#SECTION00515000000000000000">Circular buffers</A>
</UL>
<LI><A NAME="tex2html96"
  HREF="report.html#SECTION00520000000000000000">Contract programming</A>
<LI><A NAME="tex2html97"
  HREF="report.html#SECTION00530000000000000000">Satisfiability (SAT)</A>
<LI><A NAME="tex2html98"
  HREF="report.html#SECTION00540000000000000000">CBMC</A>
<LI><A NAME="tex2html99"
  HREF="report.html#SECTION00550000000000000000">Verifying properties of thread local and concurrent threads</A>
</UL><BR>
<LI><A NAME="tex2html100"
  HREF="report.html#SECTION00600000000000000000">Related work</A>
<UL>
<LI><A NAME="tex2html101"
  HREF="report.html#SECTION00601000000000000000">Binary Decision Diagrams (BDDs)</A>
</UL><BR>
<LI><A NAME="tex2html102"
  HREF="report.html#SECTION00700000000000000000">Multicore Hardware Model</A>
<UL>
<LI><A NAME="tex2html103"
  HREF="report.html#SECTION00710000000000000000">Computing platforms</A>
<LI><A NAME="tex2html104"
  HREF="report.html#SECTION00720000000000000000">Multicore Memory models</A>
<UL>
<LI><A NAME="tex2html105"
  HREF="report.html#SECTION00721000000000000000">UMA</A>
<LI><A NAME="tex2html106"
  HREF="report.html#SECTION00722000000000000000">NUMA</A>
<LI><A NAME="tex2html107"
  HREF="report.html#SECTION00723000000000000000">COMA</A>
<LI><A NAME="tex2html108"
  HREF="report.html#SECTION00724000000000000000">SRAM</A>
</UL>
<LI><A NAME="tex2html109"
  HREF="report.html#SECTION00730000000000000000">Data sharing</A>
<LI><A NAME="tex2html110"
  HREF="report.html#SECTION00740000000000000000">Ericsson hardware platform</A>
</UL><BR>
<LI><A NAME="tex2html111"
  HREF="report.html#SECTION00800000000000000000">Implementation</A>
<UL>
<LI><A NAME="tex2html112"
  HREF="report.html#SECTION00810000000000000000">DSP-C support</A>
<LI><A NAME="tex2html113"
  HREF="report.html#SECTION00820000000000000000">Contract verification</A>
<LI><A NAME="tex2html114"
  HREF="report.html#SECTION00830000000000000000">Platform specific libraries and macro support</A>
<UL>
<LI><A NAME="tex2html115"
  HREF="report.html#SECTION00831000000000000000">Memory overlays</A>
<LI><A NAME="tex2html116"
  HREF="report.html#SECTION00832000000000000000">Support for parallel programs</A>
<LI><A NAME="tex2html117"
  HREF="report.html#SECTION00833000000000000000">Internal macros</A>
</UL>
</UL><BR>
<LI><A NAME="tex2html118"
  HREF="report.html#SECTION00900000000000000000">Discussion and Conclusion</A>
<UL>
<LI><A NAME="tex2html119"
  HREF="report.html#SECTION00901000000000000000">Model checking</A>
<LI><A NAME="tex2html120"
  HREF="report.html#SECTION00902000000000000000">Contract verification</A>
<LI><A NAME="tex2html121"
  HREF="report.html#SECTION00903000000000000000">Identifying properties of thread local and concurrent threads</A>
</UL><BR>
<LI><A NAME="tex2html122"
  HREF="report.html#SECTION001000000000000000000">Future Work</A>
<LI><A NAME="tex2html123"
  HREF="report.html#SECTION001100000000000000000">Index</A>
<LI><A NAME="tex2html124"
  HREF="report.html#SECTION001200000000000000000">Bibliography</A>
<LI><A NAME="tex2html125"
  HREF="report.html#SECTION001300000000000000000">Examples of new data type and verification results</A>
<LI><A NAME="tex2html126"
  HREF="report.html#SECTION001400000000000000000">Contract verification example</A>
</UL>
<!--End of Table of Contents--><BR>

<H2><A NAME="SECTION00200000000000000000">
List of Figures</A>
</H2><OL>
<LI><A NAME="tex2html1"
  HREF="report.html#141">Function to find greatest common divisor</A>
<LI><A NAME="tex2html2"
  HREF="report.html#186">Model checking [</A><A
 HREF="report.html#clarke2008birth">8</A>]
<LI><A NAME="tex2html3"
  HREF="report.html#166">Loop unrolled greatest common divisor function</A>
<LI><A NAME="tex2html6"
  HREF="report.html#332">An example of circular buffer</A>
<LI><A NAME="tex2html7"
  HREF="report.html#345">An example of contract programming</A>
<LI><A NAME="tex2html8"
  HREF="report.html#369">An example state-machine for verification</A>
<LI><A NAME="tex2html9"
  HREF="report.html#393">Block diagram of CBMC</A>
<LI><A NAME="tex2html10"
  HREF="report.html#404">An example of loop with static condition</A>
<LI><A NAME="tex2html11"
  HREF="report.html#415">An example of unrolled loop with static condition</A>
<LI><A NAME="tex2html12"
  HREF="report.html#429">An example of loop with dynamic condition</A>
<LI><A NAME="tex2html13"
  HREF="report.html#439">An example of unrolled loop with dynamic condition</A>
<LI><A NAME="tex2html14"
  HREF="report.html#453">An example of Multiple assignments</A>
<LI><A NAME="tex2html15"
  HREF="report.html#462">Renaming variables</A>
<LI><A NAME="tex2html16"
  HREF="report.html#559">One Bit Full Adder (FA)</A> <A NAME="501"></A>
<LI><A NAME="tex2html17"
  HREF="report.html#968">Ericsson's DSP multicore platform block diagram</A>
<LI><A NAME="tex2html18"
  HREF="report.html#1069">Function calls in contract programming </A>
<LI><A NAME="tex2html19"
  HREF="report.html#1079">Example of contract programming</A>
<LI><A NAME="tex2html20"
  HREF="report.html#1094">An example of multiple function calls</A>
<LI><A NAME="tex2html21"
  HREF="report.html#1108">An example of memory overlay</A></OL><BR>

<H2><A NAME="SECTION00300000000000000000">
List of Tables</A>
</H2><OL>
<LI><A NAME="tex2html4"
  HREF="report.html#295">A platform specific definition of __fixed types</A>
<LI><A NAME="tex2html5"
  HREF="report.html#311">A platform specific definition of __accum types</A></OL>
<P>

<DIV ALIGN="CENTER">

</DIV>
<H1><A NAME="SECTION00310000000000000000">
Formal notations</A>
</H1>
<BR><P></P>
<DIV ALIGN="CENTER">
<DIV ALIGN="CENTER">

</DIV>    <TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\wedge$"></SPAN></TD>
<TD ALIGN="LEFT">Concatenation operation</TD>
</TR>
<TR><TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$\vee$"></SPAN></TD>
<TD ALIGN="LEFT">Disjunction operation</TD>
</TR>
<TR><TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$\neg$"></SPAN></TD>
<TD ALIGN="LEFT">Negation operation</TD>
</TR>
<TR><TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$\cap$"></SPAN></TD>
<TD ALIGN="LEFT">Set intersection operation</TD>
</TR>
<TR><TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$\cup$"></SPAN></TD>
<TD ALIGN="LEFT">Set union operation</TD>
</TR>
<TR><TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="28" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="$X^n$"></SPAN></TD>
<TD ALIGN="LEFT">Power (X power of n)</TD>
</TR>
<TR><TD ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.png"
 ALT="$\vdash$"></SPAN></TD>
<TD ALIGN="LEFT">Infers

<P></TD>
</TR>
</TABLE>
</DIV><BR>

<P>

<P>


<P>

<H1><A NAME="SECTION00400000000000000000">
Introduction</A>
</H1>

<P>
The complexity of hardware and software is increasing as the years are passing. With increase in complexity, likelihood of errors is much greater. A major goal of software engineering is to enable developers to implement systems which operate reliably despite the complexity. One of the ways to achieve this is by using <SPAN  CLASS="textit">formal methods</SPAN> [<A
 HREF="report.html#clarke1996formal">12</A>]. Formal methods are mathematically based techniques, tools and languages for describing and verifying the system. These techniques can greatly increase our understanding of a system by revealing incompleteness, ambiguities and inconsistencies that may go undetected otherwise [<A
 HREF="report.html#hall1990seven">20</A>].

<P>
Single core processor's speed is limited by the physics of semiconductors. High performance computers are being designed using multiple cores to reach the high computation goals. In multicore systems, applications are designed to execute in parallel, and computation speed is achieved by parallel computation. The parallel computation increases complexity of software and hardware. Research industry is working on developing tools and techniques to reduce complexity and detect possible error cases. In this work we have analysed an embedded multicore Digital Signal Processor (DSP) architecture and software, and developed <SPAN  CLASS="textit">model checking</SPAN> techniques. DSPs are processors with special functional blocks to handle digital signals. A digital signal is a sequence of discrete values which represent a physical signal, for example, representing a radio signal or audio signal. Digital signal processing can be enhanced by features like fixed point arithmetic, coprocessors and dedicated registers. Standard C language does not have explicit support to handle these features. Industry and researchers have defined extensions like Embedded-C and DSP-C to add these features to standard C. We have added support for DSP-C in our bounded model checking tool to process DSP-C based programs. We will present multicore, parallel processing, DSP functionality and DSP-C in later chapters.

<P>
<SPAN  CLASS="textit">Model checking</SPAN> is a formal method for verifying logical correctness. Proving logical correctness can be very effective in development process since testing lacks the coverage [<A
 HREF="report.html#zhu1997software">45</A>], peer review is error prone and costly. For example as we can see in fig:example:test:coverage:code, the function <!-- MATH
 $greatest\_common\_divisor$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="184" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$greatest\_common\_divisor$"></SPAN> can iterate in while loop based on values of x and y, which are dynamic values. There are <SPAN CLASS="MATH"><IMG
 WIDTH="60" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$2^N * 2^N$"></SPAN> possible inputs and <SPAN CLASS="MATH"><IMG
 WIDTH="25" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="$2^N$"></SPAN> outputs, where N is number of bits in int data type. In large software it is impractical to cover all the inputs, outputs and behaviours of each function and module. There are alternative approaches in testing, like code coverage techniques and white-box testing, which can provide some assurance of behaviour but testing cannot prove the correctness.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:test:coverage:code"></A><A NAME="141"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1.1:</STRONG>
Function to find greatest common divisor</CAPTION>
<TR><TD><IMG
 WIDTH="835" HEIGHT="19" BORDER="0"
 SRC="img11.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum width...
...
\par
return (x+y);
}
\end{lstlisting} };
\par
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
Verification techniques are being employed extensively in hardware and embedded system development. Since, hardware and embedded systems are designed, developed once and mass produced, and bugs in implementation cannot be fixed once produced. Even a single bug in system may lead to recall of all the products. Also, embedded systems have become part of our regular life. For example, microwave oven at home to safety critical systems like power plant controller or flight controllers in aircraft. A single bug in these systems can lead to fatal disasters. Verification techniques can help us to identify possible error cases. In embedded systems, verification can identify problems like checking if array access is within the defined array bound, dangling pointers, arithmetic overflow or underflow and if it is a multicore systems, data races, deadlocks and many other properties can be verified [<A
 HREF="report.html#werner2010correctness">44</A>,<A
 HREF="report.html#post2007integrated">34</A>,<A
 HREF="report.html#vasudevan2008static">41</A>].

<P>

<DIV ALIGN="CENTER"><A NAME="fig:model:checking"></A><A NAME="186"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1.2:</STRONG>
Model checking [<A
 HREF="report.html#clarke2008birth">8</A>]</CAPTION>
<TR><TD><DIV ALIGN="CENTER">

</DIV>[width=]images/modelChecking.pdf</TD></TR>
</TABLE>
</DIV>

<P>
Model checking <SPAN  CLASS="textit">statically analyses</SPAN> the implementation and asserts on properties of the logic. fig:model:checking shows the block diagram of model checking. A model checker reads program or circuit logic, converts it into a formula and compares it with the specification. Model checker matches logic and specification, and tells the implementation is incorrect if the logic differs from specification. Model checking is used to detect undesired behaviours of the system.

<P>
Software model checking is complex since it operates based on information available statically, without running programs and programs contain code segments controlled by dynamic conditions [<A
 HREF="report.html#godefroid2005software">18</A>]. Software model checking also has to cope up with loops which are bounded with run-time conditions, for instance, while loop in function <!-- MATH
 $greatest\_common\_divisor$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="184" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$greatest\_common\_divisor$"></SPAN> (fig:example:test:coverage:code) is bounded by values of x and y. Dynamically bounded programs can be verified using <SPAN  CLASS="textit">Bounded Model Checking (BMC)</SPAN>, which considers a static bound on loops [<A
 HREF="report.html#biere2003bounded">3</A>]. For instance fig:example:test:coverage:code:loopunrolled shows <!-- MATH
 $greatest\_common\_divisor$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="184" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$greatest\_common\_divisor$"></SPAN> with loop unrolled. In this example static bound used for loop unrolling is 5. As we can see assert statement at the end is used to verify if bounding limit is not enough. We should note that bounded model checking does not guarantee complete program correctness, since it verifies programs within a bounds.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:test:coverage:code:loopunrolled"></A><A NAME="166"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1.3:</STRONG>
Loop unrolled greatest common divisor function</CAPTION>
<TR><TD><IMG
 WIDTH="4178" HEIGHT="19" BORDER="0"
 SRC="img12.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum width...
...}
\par
return (x+y);
}
\end{lstlisting} };
\par
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
<SPAN  CLASS="textit">CBMC</SPAN> is a Bounded Model Checking tool which can process C and C++ programs and verify different properties [<A
 HREF="report.html#website:cprover:cbmc">27</A>,<A
 HREF="report.html#clarke2006ansi">10</A>,<A
 HREF="report.html#Clarke04atool">11</A>]. It converts programs into intermediate forms which are called <SPAN  CLASS="textit">goto-programs</SPAN><A NAME="172"></A>. The goto-programs are simplified C and C++ programs, represented in the form of Control Flow Graphs (CFG)<A NAME="173"></A>. In goto-programs, variables are renamed so that each variable is assigned only once, the transformation is called <SPAN  CLASS="textit">Static Single Assignment</SPAN> (SSA)<A NAME="175"></A> [<A
 HREF="report.html#Clarke04atool">11</A>]. CBMC also supports pointers, arrays, structures, floating point operations and function pointers. CBMC handles loops by bounding the number of iterations each loop can be executed and unrolling each loop according to the bound. We will present CBMC with more details in later chapters.

<P>

<H2><A NAME="SECTION00401000000000000000">
Contributions</A>
</H2>
Thesis work presents a study done to develop a model checking tool for Ericsson's real time DSP multicore platform. The platform uses DSP-C as its programming language. DSP-C extends the ISO C programming language with key features of Digital Signal Processing<A NAME="178"></A> (DSP) that enable efficient source code compilation [<A
 HREF="report.html#website:dspc">16</A>]. DSP-C adds the following features to ISO C:

<UL>
<LI>Fixed point arithmetic operations and data types 
</LI>
<LI>Divided memory spaces
</LI>
<LI>Circular arrays and pointers
</LI>
</UL>

<P>
We will cover more about DSP-C in later chapters. Ericsson uses contract<A NAME="182"></A> based programing, which helps large teams working together on same software. It allows programmers to define the contracts for each module and/or functions. This style of programming provides a framework where module integration is less error-prone since each developer states the requirements for their modules in the contracts [<A
 HREF="report.html#Meyer:1992:ADC:618974.619797">30</A>]. With this thesis we are providing a verifier to check validity of contracts among the function and/or modules.

<P>
We developed techniques to handle Ericsson's parallel software running on multicore DSP platform. Major challenge with the parallel/concurrent software verification includes state space explosion due to several control flow paths of parallel programs. Software architecture used in our case study does not pose state-space explosion issue since the software is statically scheduled and software does not share much data between threads and threads run independent of other threads. We also identified some of the platform features which can be verified using model checking and proposed model checking techniques. 

<P>

<H2><A NAME="SECTION00402000000000000000">
Structure of the thesis report</A>
</H2>

<P>
In second chapter we will cover the features of DSP-C, programming model of Ericsson, satisfiability (SAT) solvers, introduce CBMC and discuss about platform specific properties. Third chapter describe the related work in verification. Fourth chapter describe the multicore hardware models and Ericsson's multicore platform. Fourth chapter briefly covers the extensions developed for CBMC to work with Ericsson's software and API stubs to handle platform API calls. In fifth chapter we will discuss about results of model checking, alternative approaches, conclusion. Last chapter is dedicated to propose possible future work.

<P>

<H1><A NAME="SECTION00500000000000000000"></A> <A NAME="chap:background"></A><BR>
Background
</H1>

<P>
This chapter introduces the tools and techniques used in this thesis. We will briefly describe all the feature of DSP-C in first section. Second section concentrates on contract based programming. Third section explains satisfiability (SAT) techniques. Fourth section describes features and architectures of CBMC.

<P>

<H1><A NAME="SECTION00510000000000000000"></A><A NAME="269"></A><A NAME="sec:back:dspc"></A><BR>
DSP-C
</H1>

<P>
As the name suggests DSP-C is a programming language extension proposed by a private company, Associated Compiler Experts (ACE). It is an extension to ISO/IEC IS 9899:1900 (ISO C) standard to support the hardware features of Digital Signal Processors (DSP's) [<A
 HREF="report.html#website:dspc:specification">37</A>]. These extensions are proposed to overcome the standard C language's inability to handle divided memory spaces, circular buffers, dedicated register sets, fixed point data-types and fixed point arithmetic [<A
 HREF="report.html#dspcbenifits">36</A>].

<P>

<H2><A NAME="SECTION00511000000000000000">
Fixed point</A>
</H2>

<P>
Computing machines like calculators, computers or embedded controllers represent all the numbers in binary. Integers can be directly mapped to finite bit stream of binary digits. Common way to represent fractions is using <SPAN  CLASS="textit">floating points</SPAN> or <SPAN  CLASS="textit">fixed point</SPAN>. Floating point arithmetic supports wider range of values as it has "floating" decimal point. The number is represented using <SPAN  CLASS="textit">significant</SPAN> and <SPAN  CLASS="textit">exponent</SPAN>. [<A
 HREF="report.html#overton2001numerical">32</A>] presents the various advantages and disadvantage of floating point numbers. Commonly embedded systems do not support floating point values since floating point arithmetic require large logic, needs more computation time and energy [<A
 HREF="report.html#tiwari1995power">39</A>]. Common alternative is to use fixed point values. Fixed point use fixed number of digits after decimal point. Fixed point values are stored similar to integer values and the decimal position is known since its constant.

<P>

<H2><A NAME="SECTION00512000000000000000">
Fixed point data type</A>
</H2>

<P>
Programmers can use fixed point data types as easily as any other data types in C language, to describe fixed point arithmetic operations. Explicit support for fixed point types in programming language will allow compiler developers to design fixed point specific optimisations in compilers [<A
 HREF="report.html#dspcbenifits">36</A>]. It also provides a standardised mechanism to define and use fixed point data types.

<P>
DSP-C defines the following fixed point data types:

<P>

<H3><A NAME="SECTION00512100000000000000"></A><A NAME="283"></A><A NAME="284"></A><BR>
̣__fixed types
</H3>
Signed __fixed and unsigned __fixed types will have a mantissa value. A __fixed object represents values in the range of [-1.0, +1.0]. Number of bits used to store a __fixed is platform specific. For example, a platform specific variant of __fixed type is defined in tab:fixedtypeexample. Similarly, a platform may define short __fixed to be 16 bits.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="295"></A>
<TABLE>
<CAPTION><STRONG>Table 2.1:</STRONG>
A platform specific definition of __fixed types</CAPTION>
<TR><TD><DIV ALIGN="CENTER">

</DIV>    <TABLE CELLPADDING=3 BORDER="1">
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Type</SPAN></TH>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH=21><SPAN  CLASS="textbf">Size in bits</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Value range</SPAN></TH>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH=57><SPAN  CLASS="textbf">Step size (least value greater than 0)</SPAN></TH>
</TR>
<TR><TD ALIGN="LEFT">short __fixed</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=21>8</TD>
<TD ALIGN="LEFT">-1.0r to 0.9921875r</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>0.0078125r</TD>
</TR>
<TR><TD ALIGN="LEFT">unsigned short __fixed</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=21>7</TD>
<TD ALIGN="LEFT">0.0ur to 0.9921875r</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>0.0078215ur</TD>
</TR>
<TR><TD ALIGN="LEFT">__fixed</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=21>16</TD>
<TD ALIGN="LEFT">-1.0r to 0.99996928..r</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>0.000030..r</TD>
</TR>
<TR><TD ALIGN="LEFT">unsigned __fixed</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=21>15</TD>
<TD ALIGN="LEFT">0.0r to 0.99996928..ur</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>0.000030..ur</TD>
</TR>
</TABLE>

[NOTE: Succeeding `r' and `ur' in above value ranges represents a __fixed type signed and unsigned constants, respectively.]
<A NAME="tab:fixedtypeexample"></A></TD></TR>
</TABLE>
</DIV><P></P><BR>

<P>

<H3><A NAME="SECTION00512200000000000000"></A><A NAME="299"></A><BR>
̣__accum types
</H3>
The __accum type is similar to __fixed type with extra 8bits bits to store value before decimal point. For example __accum can store 3.142, but __fixed can only store values between [-1, +1], like 0.142. DSP-C specification [<A
 HREF="report.html#website:dspc:specification">37</A>] defines that ``__accum type shall have the same scaling factors as the corresponding __fixed types, with an extension of 8 bits, an __accum value can represent value between [-256.0 to +256.0]". For example, a platform specific variant of __accum type is defined in tab:accumtypeexample.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="311"></A>
<TABLE>
<CAPTION><STRONG>Table 2.2:</STRONG>
A platform specific definition of __accum types</CAPTION>
<TR><TD><DIV ALIGN="CENTER">

</DIV>    <TABLE CELLPADDING=3 BORDER="1">
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Type</SPAN></TH>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH=21><SPAN  CLASS="textbf">Size in bits</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Value range</SPAN></TH>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH=57><SPAN  CLASS="textbf">Step size (least value greater than 0)</SPAN></TH>
</TR>
<TR><TD ALIGN="LEFT">short __accum</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=21>16</TD>
<TD ALIGN="LEFT">-256.0a to 255.9921875a</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>0.0078125a</TD>
</TR>
<TR><TD ALIGN="LEFT">unsigned short __fixed</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=21>15</TD>
<TD ALIGN="LEFT">0.0ua to 511.9921875ua</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>0.0078215ua</TD>
</TR>
<TR><TD ALIGN="LEFT">__fixed</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=21>24</TD>
<TD ALIGN="LEFT">-256.0a to 255.99996928..a</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>0.000030..a</TD>
</TR>
<TR><TD ALIGN="LEFT">unsigned __fixed</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=21>23</TD>
<TD ALIGN="LEFT">0.0r to 511.99996928..ua</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>0.000030..ua</TD>
</TR>
</TABLE>

[NOTE: Succeeding `a' and `ua' in above value ranges represents a __accum type signed and unsigned constants, respectively.]
<A NAME="tab:accumtypeexample"></A></TD></TR>
</TABLE>
</DIV><P></P><BR>

<P>

<H3><A NAME="SECTION00512300000000000000"></A> <A NAME="315"></A><BR>
Operations on new data types
</H3>
DSP-C also defines operations and behaviours of all the operations on data types. It supports all standard C operations on new data types, such as arithmetic operations, logical operations, relational operations and a special qualifier. A special qualifier is __sat, which is only applicable to the __fixed type, makes a __fixed into __sat a qualified value, which is used during the expression evaluation phase [<A
 HREF="report.html#website:dspc:specification">37</A>]. The sat qualifier adds a saturation operation to expressions. The saturation operation returns same value if the value is less than maximum storable value in  __fixed type, otherwise it returns maximum storable value. This operation avoids over flow conditions.

<P>

<H2><A NAME="SECTION00513000000000000000"></A> <A NAME="sec:memory:lable"></A><BR>
Divided memory spaces
</H2>

<P>
DSP-C allows programmers to provide distributed memory views to compilers. Since memories in DSP's can be physically located in different places, providing divided memory view to developer gives them flexibility to decide on memory location for each variable. This is achieved through memory labelling. When a variable is defined, the label on definition tells compiler which memory will hold a particular variable.

<P>
<SPAN  CLASS="textbf">Example</SPAN>
<BR>
<IMG
 WIDTH="100" HEIGHT="33" ALIGN="BOTTOM" BORDER="0"
 SRC="img13.png"
 ALT="\begin{lstlisting}
__X int a;
__Y int b;
\end{lstlisting}">
<BR>

<P>
In above example, variable <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="$a$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img15.png"
 ALT="$b$"></SPAN> may be allocated in different memory regions, which can be in different physical memory. For instance, memory label <SPAN CLASS="MATH"><IMG
 WIDTH="30" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img16.png"
 ALT="$\_\_X$"></SPAN> will inform compiler that variable will be allocated in memory bank X and <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img17.png"
 ALT="$\_\_Y$"></SPAN> will inform that variable will be allocated in memory bank Y.

<P>

<H2><A NAME="SECTION00514000000000000000">
Dedicated register sets</A>
</H2>
DPS's normally have register set for dedicated operations. DSP-C provides register labelling to directly access these register set. Programmers can define variables with register labels, similar to memory labels, and force compilers to allocate a variable into particular register.

<P>

<H2><A NAME="SECTION00515000000000000000"></A><A NAME="324"></A><BR>
Circular buffers
</H2>
DSP-C allows arrays to be defined and used as circular buffers. DSP-C defines new data type (__circ) to  make a simple array into a circular buffer. For example in fig:example:circular:buffer, ``arr[1] = 1;" will copy 1 in array index 1 and ``arr[12] = 2;" will copy  2 in index 2.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:circular:buffer"></A><A NAME="332"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.1:</STRONG>
An example of circular buffer</CAPTION>
<TR><TD><IMG
 WIDTH="209" HEIGHT="20" BORDER="0"
 SRC="img18.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
...0];
arr[1] = 1;
arr[12] = 2;
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H1><A NAME="SECTION00520000000000000000"></A> <A NAME="sec:back:contact:prog"></A><BR>
Contract programming
</H1>
The contract programming is a technique, in which the developer states specific requirements for software components. A software component can be function or a module. Contracts define rules on how a component should be used. Contracts contain prerequisites before using the component and define outcomes after using component. A component user has to satisfy all the prerequisites of component being used and agree on possible outcomes, to use the component. For instance contracts of function <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$f$"></SPAN> can have precondition <SPAN CLASS="MATH"><IMG
 WIDTH="28" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img20.png"
 ALT="$pre$"></SPAN> and postcondition <SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img21.png"
 ALT="$post$"></SPAN>. Contracts of function <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$f$"></SPAN> are satisfied if the function <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$f$"></SPAN> is invoked in state satisfying <SPAN CLASS="MATH"><IMG
 WIDTH="28" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img20.png"
 ALT="$pre$"></SPAN> and either <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$f$"></SPAN> does not terminate, or in final state of executing <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$f$"></SPAN>, the post-condition <SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img21.png"
 ALT="$post$"></SPAN> holds. These contracts help developers to write code under a safety net and components with contracts tend to be less error prone. [<A
 HREF="report.html#Meyer:1992:ADC:618974.619797">30</A>]

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:contract:programming"></A><A NAME="345"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.2:</STRONG>
An example of contract programming</CAPTION>
<TR><TD><IMG
 WIDTH="806" HEIGHT="20" BORDER="0"
 SRC="img22.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
...{
ptr++;
\par
return ptr;
}
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
In the example fig:example:contract:programming, precondition checks if the pointer is a NULL pointer and postcondition checks if the memory address reaches its max value.

<P>

<H1><A NAME="SECTION00530000000000000000"></A> <A NAME="sec:sat:solver"></A><BR>
Satisfiability (SAT)
</H1>

<P>
<A NAME="351"></A><A NAME="352"></A> Satisfiability (SAT) has been hot research topic, since SAT has shown high potential in verifying large systems [<A
 HREF="report.html#moskewicz2001chaff">31</A>]. SAT solvers work using satisfiability procedures in the core for propositional logic [<A
 HREF="report.html#DeMoura:2011:SMT:1995376.1995394">14</A>]. Propositional logic is a predicate in which formula contains Boolean variables, known as atoms, and variables are connected using logical directives like conjunction, disjunction and negation.  If <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img23.png"
 ALT="$z$"></SPAN> is Boolean variable and, <SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$exp_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$exp_2$"></SPAN> are expressions built from Boolean variables, then we can define following formulas.

<P>

<UL>
<LI><SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img23.png"
 ALT="$z$"></SPAN> is a Boolean variable and can be evaluated to 0 or 1.
</LI>
<LI><SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$exp_1$"></SPAN> is expression containing Boolean variables.
</LI>
<LI><SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img26.png"
 ALT="$\neg exp_1$"></SPAN> is expression containing negation on <SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$exp_1$"></SPAN>.
</LI>
<LI><SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$exp_1$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$\vee$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$exp_2$"></SPAN> is a disjunctive expression on two expressions.
</LI>
<LI><SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$exp_1$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$\wedge$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$exp_2$"></SPAN> is a conjunctive expression on two expressions.
</LI>
</UL>

<P>
<!-- MATH
 $(\neg X \vee Y)  \wedge (Y \wedge Z))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="151" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.png"
 ALT="$(\neg X \vee Y) \wedge (Y \wedge Z))$"></SPAN> from fig:example:statemachine, is an example for formula constructed from above rules. And the formula can be evaluated to 0 or 1 based the values of all the variables. For example with <SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img28.png"
 ALT="$X=1$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img29.png"
 ALT="$Y=0$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.png"
 ALT="$Z=0$"></SPAN> assignment formula is evaluated to 0, and <SPAN CLASS="MATH"><IMG
 WIDTH="97" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$X=0, Y=1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.png"
 ALT="$Z=1$"></SPAN> assignment formula is evaluated to 1. This example illustrates, variables can be constrained through operators, for instance for formula to be 1, <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img33.png"
 ALT="$Z$"></SPAN> must be 1. <SPAN  CLASS="textit">Boolean Satisfiability</SPAN> of a formula is a process of finding an assignment which evaluates it to 1. In this example <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img34.png"
 ALT="$Y=1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.png"
 ALT="$Z=1$"></SPAN> assignment will make the formula to be evaluated to 1 and satisfy it. The formulas which cannot be satisfied with any possible assignment are called unsatisfiable. For example, <!-- MATH
 $(\neg a \vee b) \wedge (a \vee \neg b)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="134" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$(\neg a \vee b) \wedge (a \vee \neg b)$"></SPAN> cannot be satisfied with any assignments and hence unsatisfiable.

<P>
SAT problem is NP-Complete [<A
 HREF="report.html#Malik:2009:BST:1536616.1536637">29</A>]. Most SAT solvers use restricted representation of formulas in Conjunctive Normal Formula (CNF). A formula in Conjunctive Normal Form (CNF) is a congestion of clauses. A clause is disjunction of literals. A literal is a Boolean variable, or negation of Boolean variable. For example, <!-- MATH
 $(a \vee b \vee \neg c \vee d) \wedge (a \vee b \vee \neg d \vee e)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="236" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$(a \vee b \vee \neg c \vee d) \wedge (a \vee b \vee \neg d \vee e)$"></SPAN>, here <!-- MATH
 $(a \vee b \vee \neg d \vee e)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="111" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.png"
 ALT="$(a \vee b \vee \neg d \vee e)$"></SPAN> is a clause with set of variables with or without negation. The approach for finding satisfiability differs in different tools. One of the commonly used approaches is DPLL [<A
 HREF="report.html#Davis:1962:MPT:368273.368557">13</A>]. In DPLL, given a CNF formula, the algorithm heuristically chooses an unassigned variable and assigns it a value, 0 or 1, this step is known as branching step. Then solver tries to simplify the consequences based on deduction rule. In deduction it tries to deduce if any of clause become 0. If one of the assignments leads 0, the algorithm back tracks since it will not lead to any satisfiability. Once it assigns a combination of values to all the variables which can be 1, the formula is said to be satisfiable.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:statemachine"></A><A NAME="369"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.3:</STRONG>
An example state-machine for verification</CAPTION>
<TR><TD><IMG
 WIDTH="61" HEIGHT="16" BORDER="0"
 SRC="img38.png"
 ALT="\begin{figure}\centering
\begin{tikzpicture}[-&gt;, &gt;=stealth', auto, node distanc...
...\vee Z$} (B)
(B) edge node {$Z \wedge Y$} (C);
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H1><A NAME="SECTION00540000000000000000"></A> <A NAME="373"></A> <A NAME="sec:back:cbmc"></A><BR>
CBMC
</H1>

<P>
CBMC is an open source Bounded Model Checker for ANSI-C and C++ programs [<A
 HREF="report.html#website:cprover:cbmc">27</A>]. Bounded model checking is a technique to verify programs within defined bounds. We will discuss more about bounded model checking in next section. CBMC compiles ANSI-C or C++ into goto-programs and verifies properties of the program using bounded model checking techniques. The goto-programs are simplified C and C++ programs, represented in the form of Control Flow Graphs (CFG). The properties includes checking if an assertion is true, array bound limits, dangling pointers, arithmetic overflow/underflow and some other platform specific properties as listed in [<A
 HREF="report.html#website:cprover:cbmc">27</A>]. fig:CBMC:block shows the block diagram of CBMC. Front end compiles source code to intermediate form, called goto-programs. The loops in goto-programs are unrolled.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:CBMC:block"></A><A NAME="393"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.4:</STRONG>
Block diagram of CBMC</CAPTION>
<TR><TD><IMG
 WIDTH="125" HEIGHT="35" BORDER="0"
 SRC="img39.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
...nf) - (smt);
\path[line] (smt) - (cnf);
\end{tikzpicture}
\par
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00540100000000000000">
Loop Unrolling</A>
</H3>
Loop unrolling, also called as loop unwinding, is process of converting loops into sequential statements. For example:

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:loop:with:static:condition"></A><A NAME="404"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.5:</STRONG>
An example of loop with static condition</CAPTION>
<TR><TD><IMG
 WIDTH="263" HEIGHT="20" BORDER="0"
 SRC="img40.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
...y_a[i] = array_b[i] + 100;
}
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
Example fig:example:loop:with:static:condition can be simply converted as shown in fig:example:unrolled:loop:with:static:condition, which contains sequential statements.

<DIV ALIGN="CENTER"><A NAME="fig:example:unrolled:loop:with:static:condition"></A><A NAME="415"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.6:</STRONG>
An example of unrolled loop with static condition</CAPTION>
<TR><TD><IMG
 WIDTH="779" HEIGHT="20" BORDER="0"
 SRC="img41.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
...ray_a[4] = array_b[4] + 100;
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
Typically there are also loops which are bounded by run-time conditions, for example in fig:example:loop:with:dynamic:condition. C code in fig:example:loop:with:dynamic:condition contains a while loop which terminates when array_b encounters an end of string character (<SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$\backslash 0$"></SPAN>) in its index. Static analysis may not provide any information about the contents of arry_b and it is impossible to know the number of iteration loop will run during execution. Most of the tools use bounded loop unrolling, i.e. if the exit condition for a loop cannot be determined statically, loops are unrolled a maximum of N number of times. Number N can be adjusted according to application. For instance above loop in fig:example:loop:with:dynamic:condition, with N set to 5, can be transformed as shown in fig:example:unrolled:loop:with:dynamic:condition.

<DIV ALIGN="CENTER"><A NAME="fig:example:loop:with:dynamic:condition"></A><A NAME="429"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.7:</STRONG>
An example of loop with dynamic condition</CAPTION>
<TR><TD><IMG
 WIDTH="306" HEIGHT="20" BORDER="0"
 SRC="img43.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
...y_a[i] = array_b[i];
i++;
}
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:unrolled:loop:with:dynamic:condition"></A><A NAME="439"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.8:</STRONG>
An example of unrolled loop with dynamic condition</CAPTION>
<TR><TD><IMG
 WIDTH="2974" HEIGHT="20" BORDER="0"
 SRC="img44.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
... assert(0);
}
}
}
}
}
}
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
Assert statement, at last, can be used to check if unrolling was not enough.

<P>

<H3><A NAME="SECTION00540200000000000000">
Goto-programs</A>
</H3>
Goto-program is compiled source code, which stores program's information in a structured way. The information includes Control Flow Graph (CFG), data types of the variable, type conversions, library functions and etc.

<P>

<H3><A NAME="SECTION00540300000000000000">
Variable renaming</A>
</H3>
Programs also have variables with multiple assignments on same control flow path and it adds complexity on the way we verify programs. To avoid the complexity, variables are renamed whenever new values are assigned. It is known as Static Single Assignment (SSA<A NAME="444"></A>). This process is done on goto-programs before converting programs into propositional logic. For example, source code shown in fig:example:multiple:assignments can be represented as: 

<P>
<!-- MATH
 $a = 10 \wedge sum = sum + a \wedge sum > MAX\_VALUE$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="357" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.png"
 ALT="$ a = 10 \wedge sum = sum + a \wedge sum &gt; MAX\_VALUE$"></SPAN>

<P>
As we can see in the expression, <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img46.png"
 ALT="$sum$"></SPAN> is assigned a value and used as a source in the expression. It is not possible to represent such expressions in proposition logic. To avoid it, CBMC converts logic as shown in fig:example:renaming:varibales.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:multiple:assignments"></A><A NAME="453"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.9:</STRONG>
An example of Multiple assignments</CAPTION>
<TR><TD><IMG
 WIDTH="287" HEIGHT="20" BORDER="0"
 SRC="img47.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
......
assert(sum &gt; MAX_VALUE)
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:renaming:varibales"></A><A NAME="462"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.10:</STRONG>
Renaming variables</CAPTION>
<TR><TD><IMG
 WIDTH="297" HEIGHT="20" BORDER="0"
 SRC="img48.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
.....
assert(sum1 &gt; MX_VALUE);
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00540400000000000000">
Bit vector flattening</A>
</H3>
After compiling a source file, we get goto-program. Next step is to verify properties of program and technique used to check these properties is called decision procedure. A decision procedure is a program which terminates with definite answer, true or false, for a decision problem. The decision procedure can decide on control flows based on previous assignments/operation. For example, decision procedure can identify if a control flow can trigger an assertion based on previous assignments and operations. 

<P>
Standard ways of implementing decision procedure is bit vector flattening followed by a call to a propositional SAT solver. In this process first step is encoding  statements from goto-program into bit vectors. Encoding variables and constants to bit vectors is a straight forward task, for example a variable X of size N, can be encoded into bit vectors b of length N. Bit vector operations have to be handled on individual bases. For example, let X, Y and Z be integer variable and a[n], b[n] and c[n] be the bit vectors for each variable respectively. For addition of two bits, we can use a one bit full adder circuit as in fig:bitadder. The circuit will provide us with following formula.

<P>
<!-- MATH
 $S_i = (a_i + b_i + C_{in}) mod_2   \longleftrightarrow  (a_i \oplus b_i \oplus c_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="307" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img49.png"
 ALT="$S_i = (a_i + b_i + C_{in}) mod_2 \longleftrightarrow (a_i \oplus b_i \oplus c_i)$"></SPAN>

<P>
<!-- MATH
 $C_{out} = (a_i + b_i + C_{in}) div_2   \longleftrightarrow  (a_i \cdot b_i + a_i \cdot C_{in} + b_i \cdot C_{in})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="411" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$C_{out} = (a_i + b_i + C_{in}) div_2 \longleftrightarrow (a_i \cdot b_i + a_i \cdot C_{in} + b_i \cdot C_{in})$"></SPAN>

<P>
Bit flattening is a process of transforming bit vector logic into propositional logic [<A
 HREF="report.html#3540741046">28</A>]. For example above bit vector logic can be converted to a propositional logic for <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="$S_i$"></SPAN>.

<P>
<!-- MATH
 $(a_i \vee b_i \vee \neg C_{out}) \wedge (a \vee \neg b \vee C_{in} \vee \neg C_{out}) \wedge (a \vee \neg b \vee \neg C_{in} \vee C_{out}) \wedge$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="480" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$ (a_i \vee b_i \vee \neg C_{out}) \wedge (a \vee \neg b \vee C_{in} \vee \neg C_{out}) \wedge (a \vee \neg b \vee \neg C_{in} \vee C_{out}) \wedge $"></SPAN>

<P>
<!-- MATH
 $(\neg a \vee b \vee C_{in} \vee \neg C_{out}) \wedge (\neg a \vee b \vee \neg C_{in} \vee  C_{out}) \wedge (\neg a \vee \neg b \vee C_{out})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="469" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img53.png"
 ALT="$(\neg a \vee b \vee C_{in} \vee \neg C_{out}) \wedge (\neg a \vee b \vee \neg C_{in} \vee C_{out}) \wedge (\neg a \vee \neg b \vee C_{out})$"></SPAN>

<P>
Similarly we can build carry chain adder for bit vectors, subtractor for subtract operation, bit wise operations etc. The multiplication, division and modulo operations generate large formulas. To handle large expressions and large operations incremental flattening is used [<A
 HREF="report.html#3540741046">28</A>].

<P>
As we know from sec:sat:solver, a proposition logic can be verified using SAT solvers. SAT solver can work on propositional logic of program logic to verify expressions and check different properties of the program logic.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:bitadder"></A><A NAME="559"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.11:</STRONG>
One Bit Full Adder (FA) <A NAME="501"></A></CAPTION>
<TR><TD></TD></TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00540500000000000000">
CBMC keywords</A>
</H3>
Apart from automatically checking properties of program, CBMC also provides set of keywords, which can be used to aide CBMC with more information about program. These keywords can be used for programs instrumentation. The program instrumentation is a procedure change or adds part code to verify some properties of the code.

<P>

<OL>
<LI><SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$assert(expr)$"></SPAN> or <!-- MATH
 $\_\_CPROVER\_assert(expr)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="198" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.png"
 ALT="$\_\_CPROVER\_assert(expr)$"></SPAN> can be used to assert on any condition. It takes a Boolean expression <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img57.png"
 ALT="$expr$"></SPAN> as argument. When CBMC encounters one of these keywords, it tries to generate a formula to check assertion failure. Generated formula is verified using SAT-solvers. If the formula is satisfied then assertion fails and CBMC generates error and produces counter-example showing possible trace of error.
</LI>
<LI><!-- MATH
 $\_\_CPROVER\_assume(expr)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="207" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$\_\_CPROVER\_assume(expr)$"></SPAN> keyword reduces the number of program traces that are considered and allows assume-guarantee reasoning. As <SPAN CLASS="MATH"><IMG
 WIDTH="49" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img59.png"
 ALT="$assert$"></SPAN>, <!-- MATH
 $\_\_CPROVER\_assume(expr)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="207" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$\_\_CPROVER\_assume(expr)$"></SPAN> also takes a Boolean expression [<A
 HREF="report.html#clarke2006ansi">10</A>].
</LI>
</OL>

<P>

<H3><A NAME="SECTION00540600000000000000">
Use cases of CBMC</A>
</H3>
CBMC was used in several case studies, including Bounded Model Checking of Concurrent Programs [<A
 HREF="report.html#Rabinovitz05boundedmodel">35</A>], Equivalence Checking [<A
 HREF="report.html#Staats:2008:PTV:1482985.1483006">38</A>], Worst Case Execution Time analysis [<A
 HREF="report.html#springerlink:10.1007_978-3-540-88479-8_30">43</A>,<A
 HREF="report.html#Kim_usinga">24</A>] and many other can be found in [<A
 HREF="report.html#website:cprover:cbmc:applications">26</A>].

<P>

<H1><A NAME="SECTION00550000000000000000">
Verifying properties of thread local and concurrent threads</A>
</H1>

<P>
Model checking is also used to verify specific properties of a system. Some properties are local to a single thread running in the system and some depend on multiple threads running concurrently. The software concurrency in a single core system is introduced by context switches and parallel computing platforms have concurrent execution paths.

<P>
Thread local properties include memory access mechanisms, correctness of memory management and pattern of mutex accesses. For example work done in [<A
 HREF="report.html#Donaldson:2011:AAD:2034876.2034900">15</A>] is used to identify DMA race conditions in IBM cell processors. In this case study, DMA race detection is achieved through <SPAN  CLASS="textit">program instrumentation</SPAN>. In program instrumentation, a part of code is added or modified to verify some properties of the logic. For example, to verify array bound, one can add an assertion to check the index value on every array access.

<P>
In concurrent programs we can observe more complex properties. For example, concurrent access to shared resources, signalling between the threads and dynamic memory management among threads or race conditions among the threads. Behaviour of these properties depends on the hardware and operating system support. The program instrumentation can be used to verify these properties.

<P>

<H1><A NAME="SECTION00600000000000000000"></A><A NAME="sec:verification:tech"></A><BR>
Related work
</H1>

<P>
Initially logical systems were verified using proof based systems. In proof based verification, system description is represented using a set of formulas <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img60.png"
 ALT="$\gamma$"></SPAN> in a suitable logic and specification is represented using another formula <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img61.png"
 ALT="$\theta$"></SPAN>. The verification of system is done by finding proof that <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img60.png"
 ALT="$\gamma$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.png"
 ALT="$\vdash$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img61.png"
 ALT="$\theta$"></SPAN>. As we can see this process is deductive and usually requires human guidance [<A
 HREF="report.html#Hoare04communicatingsequential">22</A>,<A
 HREF="report.html#Apt:1981:TYH:357146.357150">1</A>].

<P>
The work done by Vardi and Wolper in [<A
 HREF="report.html#VardiW86">40</A>], provided a way of modelling the program specifications into formulas which can be verified automatically. According to this proposal, once expected behaviours and use cases are decided, all the requirements are written into formal specification, which is mathematical description of the system. The formal specifications are written in Linear time Temporal Logic (LTL) and the LTL logic are verified to check the properties of the system. If the system described using LTL behaves as expected, the system is said to be bug free.

<P>
Currently we have techniques to convert programs described in high level programming language to mathematical formulas and automated verification technique to verify the properties of the formulas. The sec:back:cbmc describes more details of converting programs to verifiable mathematical formulas and verification using Bounded Model Checking.

<P>
Specifications and program are converted into mathematical formulas and the formulas have to be verified for correctness and check for incorrect behaviours. For example consider model checking of state-machine in fig:example:statemachine. State <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$S_3$"></SPAN> can be reached through <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img63.png"
 ALT="$S_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img64.png"
 ALT="$S_2$"></SPAN> under the condition <!-- MATH
 $(\neg X \vee Z) \wedge (Z \wedge Y)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="144" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img65.png"
 ALT="$(\neg X \vee Z) \wedge (Z \wedge Y)$"></SPAN>. Suppose we want to know if <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$S_3$"></SPAN> is reachable under certain conditions, which may violate the specification and is an incorrect behaviour. We need techniques to process the formula <!-- MATH
 $(\neg X \vee Z) \wedge (Z \wedge Y)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="144" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img65.png"
 ALT="$(\neg X \vee Z) \wedge (Z \wedge Y)$"></SPAN> and check if it is satisfiable. Such techniques are called <SPAN  CLASS="textit">decision procedures</SPAN>. Two of the commonly used decision procedures are <SPAN  CLASS="textit">Binary Decision Diagrams (BDDs)</SPAN> and <SPAN  CLASS="textit">Satisfiability (SAT)</SPAN> [<A
 HREF="report.html#kroening2008decision">25</A>]. In previous chapter we have discussed about satisfiability and next section describes BDD briefly.

<P>
``A program verifier uses automated mathematical and logical reasoning to check the consistency of programs with their internal and external specifications" [<A
 HREF="report.html#Hoare03theverifying">23</A>]. Hardware and software verification considers checking the correctness of functionality and finding undesired behaviours in the designed logic. There are several stages and ways in which a system can be verified. During the design process a system specification is developed and a mathematical model can be implemented to verify if the properties of specified system are as expected. The implemented logic can be converted into mathematical logic and this mathematics logic can be verified for its correctness. There are already tools which can work with system specifications like UML and automatons. For example http://move.lip6.fr/software/BCC/index.htmlBCC and http://www.uppaal.com/UPPAAL. Also there are tools which can work with implementation done in programming languages like C, C++, Verilog or VHDL. For example, http://www.cprover.org/cbmc/CBMC, http://www.cprover.org/satabs/SatAbs and http://www.cs.cmu.edu/&nbsp;modelcheck/vcegar/VCEGAR. 

<H2><A NAME="SECTION00601000000000000000">
Binary Decision Diagrams (BDDs)</A>
</H2>

<P>
<A NAME="538"></A><A NAME="539"></A>Graph based verification techniques like <SPAN  CLASS="textit">Binary Decision Diagrams (BDDs)</SPAN>, as described in [<A
 HREF="report.html#Bryant:1986:GAB:6432.6433">5</A>]. The BDDs are proven to be very effective in verifying binary logic [<A
 HREF="report.html#brace1991efficient">4</A>]. In this approach the model is described in-terms of a Directed Acyclic Graph (DAG) consisting of decision nodes and terminal nodes. 

<P>
Although BDDs are effective in solving verification problem, as the number of variables/nodes increase the size of BDDs increases exponentially and it is not practical to use BDDs, since verification process will be too slow and too memory consuming [<A
 HREF="report.html#clarke1997model">7</A>]. There have been attempts to develop techniques which can avoid the exponential growth, for instance work shown in [<A
 HREF="report.html#Burch90symbolicmodel">6</A>,<A
 HREF="report.html#Balarin:1993:IAL:647762.735495">2</A>,<A
 HREF="report.html#Pixley:1992:ECS:113938.149645">33</A>] and work by Bryant in [<A
 HREF="report.html#Bryant:1986:GAB:6432.6433">5</A>] showed that ordering variables will increase the efficiency of the algorithm. But despite all the efforts state explosion has been a major hurdle in applying BDD-based model checking to large and complex systems [<A
 HREF="report.html#springerlink:10.1007-3-540-44577-3-12">9</A>].

<P>

<H1><A NAME="SECTION00700000000000000000">
Multicore Hardware Model</A>
</H1>

<P>
The computers are used in diverse applications. Applications may provide unique challenge on the way computers process data. For example some application may have one algorithm to be run large amount of data and some others may require large amount of instructions to be executed on small amount of data. These requirements have defined the architecture of computers.

<P>
In this chapter we briefly present the Flynn's taxonomy, discuss about multicore memory models, data sharing concepts and introduce to the Ericsson's DSP multicore platform.

<P>
In this chapter we briefly present the Flynn's taxonomy, discuss about multicore memory models and data sharing concepts.

<P>
Model and architecture of hardware used for this thesis are intellectual property of Ericsson. This chapter only presents common multicore architectures.

<P>

<H1><A NAME="SECTION00710000000000000000">
Computing platforms</A>
</H1>

<P>
The computing platforms are generally classified based on Flynn's taxonomy [<A
 HREF="report.html#flynn1966very">17</A>]. The classification is based on number of data and instruction streams. The classification is as follows: 

<P>

<OL>
<LI>Single Instruction Stream-Single Data Stream (SISD)

<P>
A computing unit with single instruction stream and single data stream. For example: single core micro-controllers and micro-processors.

<P>
</LI>
<LI>Single Instruction Stream-Multiple Data Stream (SIMD)

<P>
Multiple computing units process same instruction on different data stream. For example: Graphical Processing Units (GPU).

<P>
</LI>
<LI>Multiple Instruction Stream-Single Data Stream (MISD)

<P>
Multiple computing units process different instruction on same data. For example fault tolerant systems run different algorithms on same data and analyse the result from both the algorithm.

<P>
</LI>
<LI>Multiple Instruction Stream-Multiple Data Stream (MIMD).

<P>
Multiple instructions streams work on different data. For example, general purpose parallel computers.

<P>
</LI>
</OL>

<P>
Parallel computing makes use of multiple computational units to process data at same time (in parallel) [<A
 HREF="report.html#hennessy2011computer">21</A>]. The architecture of parallel computers can be SIMD, MISD, MIMD or <SPAN  CLASS="textit">heterogeneous architecture</SPAN>, which is a combination of these architectures.

<P>

<H1><A NAME="SECTION00720000000000000000">
Multicore Memory models</A>
</H1>

<P>
The memory model defines the organisation and access mechanisms of computer memory. The memory models are designed to address application specific requirements. The memory models can be classified into Uniformed Memory Access (UMA), Non-Uniform Memory Access, Cache Only Memory Access and Scratchpad Random Memory Access (SRAM).

<P>

<H2><A NAME="SECTION00721000000000000000">
UMA</A>
</H2>

<P>
In UMA architecture, all the processors share a common main memory and any processor's memory access time to any of the memory region of main memory is independent [<A
 HREF="report.html#hennessy2011computer">21</A>].

<P>

<H2><A NAME="SECTION00722000000000000000">
NUMA</A>
</H2>

<P>
In NUMA architecture, all the processors share a common main memory and access time to a memory region depends on the address space of main memory it is accessing [<A
 HREF="report.html#hennessy2011computer">21</A>].

<P>

<H2><A NAME="SECTION00723000000000000000">
COMA</A>
</H2>

<P>
In COMA architecture, processors do not have a main memory, instead the processors are interconnected and support caches. The data is accessed through caches and <SPAN  CLASS="textit">cache coherency</SPAN> protocol is used.[<A
 HREF="report.html#hagersten1992ddm">19</A>,<A
 HREF="report.html#hennessy2011computer">21</A>]

<P>

<H2><A NAME="SECTION00724000000000000000">
SRAM</A>
</H2>

<P>
In SRAM architecture, all processors support memory blocks supported controlled by programs, called scratchpad memories, as replacement for cache [<A
 HREF="report.html#hennessy2011computer">21</A>].

<P>

<H1><A NAME="SECTION00730000000000000000">
Data sharing</A>
</H1>

<P>
The parallel programs running in different cores or processors can share data to produce results. Data sharing can be done through sharing memory or through message transfer. In multicore systems, cores are physically near and it is less time consuming to share memory. Any of the above memory models can be used for data sharing. To maintain correctness of data shared by parallel programs, programmers have option of using mutex and <SPAN  CLASS="textit">coherency protocols</SPAN> to keep the data consistent among different cores.

<P>

<H1><A NAME="SECTION00740000000000000000">
Ericsson hardware platform</A>
</H1>

<P>
The platform used for this thesis is a home grown ASIC processor from Ericsson. Platform is designed for <SPAN  CLASS="textit">LTE</SPAN> base stations. The LTE (Long Term Evolution) <A NAME="964"></A> is a wireless network standard with high speed data access facilities for mobile phones.

<P>
The LTE has large data and instruction parallelism, which has influenced the architecture of the platform. The platform contains multiple cores arranged in heterogeneous architecture with scratchpad memory. fig:ericsson:platform shows the block diagram of platform. The platform contains master cores and slave cores with local scratchpad memory. The cores also share a common scratchpad memory. The master cores are designed to handle incoming radio signals. The master core fetches incoming signal data through peripheral interface. The master cores distribute work computation among slave cores. The slave cores are utilised to accelerate the computation by master cores.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:ericsson:platform"></A><A NAME="968"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Ericsson's DSP multicore platform block diagram</CAPTION>
<TR><TD><DIV ALIGN="CENTER">

</DIV>[scale=0.8]images/EricssonArchitecture.pdf

<P>

<P></TD></TR>
</TABLE>
</DIV>

<P>

<P>

<H1><A NAME="SECTION00800000000000000000"></A> <A NAME="chap:implementation"></A><BR>
Implementation
</H1>

<P>
In this chapter we will present implementation part of the thesis. First section describes about DSP-C support implemented in CBMC, second section is dedicated to contract programming, third section talks about memory overlay handling and last section presents the support for parallel programs in multicore platform.

<P>
Note that, software we were working with was property of Ericsson. We cannot publish real examples, to avoid intellectual property rights violation. We are using toy programs as examples to present the concepts.

<P>

<H1><A NAME="SECTION00810000000000000000"></A> <A NAME="1050"></A><BR>
DSP-C support
</H1>

<P>
As we presented DSP-C in sec:back:dspc, DSP-C extends ISO C with new data types and operations. Also we looked at framework of CBMC in sec:back:cbmc. CBMC processes source code, produces goto-programs, goto-programs are converted propositional logic and verified using SAT-solver. To begin with we needed to add support in parser for parsing new data types, constants, operations and memory labels. Then parsed data formats have to be stored in goto-programs in a structured way to be processed during propositional logic conversion. The propositional logic conversion module has to be updated for handling new structures in goto-programs.

<P>
We updated new grammar to handle new data types, constant types and memory labels.  With working parser to parse the new type, we added logic to handle automatic type conversions between fixed arithmetic to any of ISO supported basic data types, like int, float or character.

<P>
CBMC has been updated recently to convert fixed types to propositional logic. It works by remembering total number of bits to store a fixed point and bits for fraction in it. We developed a logic in which we can feed these numbers dynamically, during conversion. With this modification, we can handle multiple types of fixed point, type conversions and operations. The current implementation can easily work with addition, subtraction and multiplication of fixed point type.

<P>
The modified CBMC tool can process features of DSP-C and some of the simple test runs are been presented in Appendix A.

<P>
As we understood from sec:memory:lable memory labels provide information about storage location of each variable and pointer's pointing location. In current implementation, we store all the memory labels in goto-programs as property of variables. In future one can use memory labels to verify the properties related to memory.

<P>

<H1><A NAME="SECTION00820000000000000000"></A><A NAME="1055"></A> <A NAME="impl:contracts"></A><BR>
Contract verification
</H1>

<P>
We studied the use cases and advantages of contract programming in sec:back:contact:prog. Our goals were to implement a mechanism to verify, if a postcondition can be proven false based on precondition and verify if the caller's contract violate the callee's contracts or callee's contracts can violate caller's contacts. For instance fig:impl:contract:funcall shows a generic pseudo code for function caller and callee with contracts. As we can see there can be two kinds of contract violations possible in <!-- MATH
 $function\_callee$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="114" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="$function\_callee$"></SPAN>. First, postcondition of a function can fail because of its own preconditions. For example, <SPAN CLASS="MATH"><IMG
 WIDTH="60" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="$pre_cond$"></SPAN> can be <SPAN CLASS="MATH"><IMG
 WIDTH="87" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img68.png"
 ALT="$state==X$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="66" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$post_cond$"></SPAN> can be <SPAN CLASS="MATH"><IMG
 WIDTH="86" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img70.png"
 ALT="$state==Y$"></SPAN>, and there can be feasible path with state to be X, but does not have assignment to state variable to be Y. This will violate the postcondition based on precondition. Second, precondition of callee, <!-- MATH
 $precondition(pre\_callee)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="175" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img71.png"
 ALT="$precondition(pre\_callee)$"></SPAN>, can fail because of precondition of caller <!-- MATH
 $precondition(pre\_caller)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="176" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="$precondition(pre\_caller)$"></SPAN>.  For example, callee can have precondition with <SPAN CLASS="MATH"><IMG
 WIDTH="87" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img68.png"
 ALT="$state==X$"></SPAN> and caller with <SPAN CLASS="MATH"><IMG
 WIDTH="87" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img68.png"
 ALT="$state==X$"></SPAN>, and a feasible path from precondition of caller to precondition of callee with assignment <SPAN CLASS="MATH"><IMG
 WIDTH="73" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$state=Y$"></SPAN> can violate the contract of callee.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:impl:contract:funcall"></A><A NAME="1069"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.1:</STRONG>
Function calls in contract programming </CAPTION>
<TR><TD><IMG
 WIDTH="166" HEIGHT="115" BORDER="0"
 SRC="img74.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, minimum height=4.5em, text w...
...listing} };
\path[line] (fun1) - (fun2);
\end{tikzpicture}
\par
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
The implementation proved to be much simpler since CBMC already provides keywords like <!-- MATH
 $\_\_CPROVER\_assume$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="163" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$\_\_CPROVER\_assume$"></SPAN> and <!-- MATH
 $\_\_CPROVER\_assert$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="153" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$\_\_CPROVER\_assert$"></SPAN>. To verify contract violation within a function, we had to replace all the callee preconditions with <!-- MATH
 $\_\_\_CPROVER\_assert$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="159" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img77.png"
 ALT="$\_\_\_CPROVER\_assert$"></SPAN> and caller initiator with <!-- MATH
 $\_\_CPROVER\_assume$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="163" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$\_\_CPROVER\_assume$"></SPAN>. It can be simply done by defining appropriate macro to replace during pre-processing stage of CBMC. When CBMC starts processing preconditions and postcondition, it assumes on initial function entry and asserts on every callee's precondition.

<P>
For second type of contract verification, we replaced preconditions with <!-- MATH
 $\_\_CPROVER\_assume$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="163" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$\_\_CPROVER\_assume$"></SPAN> and postcondition with <!-- MATH
 $\_\_CPROVER\_assert$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="153" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$\_\_CPROVER\_assert$"></SPAN>. When CBMC starts processing a function it assumes all the preconditions and starts processing statements between precondition and postcondition. If assumption together with following operations violates the postcondition, violations are caught in <!-- MATH
 $\_\_CPROVER\_assert$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="153" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$\_\_CPROVER\_assert$"></SPAN>.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:typical:contract:programming"></A><A NAME="1079"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.2:</STRONG>
Example of contract programming</CAPTION>
<TR><TD><IMG
 WIDTH="2323" HEIGHT="20" BORDER="0"
 SRC="img78.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
...dition (door_open == true)
}
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
In example shown in fig:example:typical:contract:programming, <SPAN CLASS="MATH"><IMG
 WIDTH="74" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img79.png"
 ALT="$open\_door$"></SPAN> function is written to automatically open the door. It has preconditions for checking if the lock is not on and door is not opened already. Postcondition checking the door is open once operations are performed. The CBMC tries to check contracts between caller and calee, it will make sure that caller satisfies the requirements before it calls the function. Also when contacts are used to verify functionality of a function, we can easily find any issues with postcondition based on preconditions. Appendix B presents an example run.

<P>

<H1><A NAME="SECTION00830000000000000000">
Platform specific libraries and macro support</A>
</H1>

<P>
In this section we will briefly summarise the platform related library support we implemented.

<P>

<H2><A NAME="SECTION00831000000000000000">
Memory overlays</A>
</H2>
In some applications part of data is never reused or written back to permanent storage. Also, when we look at embedded systems, in most cases executing instructions are always kept in read only memory and whenever necessary data is brought to instruction memory, cache or scratchpad. Memory overlay is a process in which part of memory is overwritten without worrying about previous contents of it.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:multiple:funcalls"></A><A NAME="1094"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.3:</STRONG>
An example of multiple function calls</CAPTION>
<TR><TD><IMG
 WIDTH="802" HEIGHT="20" BORDER="0"
 SRC="img80.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
...print_number(number);
...
}
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
In example shown in fig:example:multiple:funcalls, main generates a random number and prints it before going further with other processing. In case, programmer knows she or he is not going to use <!-- MATH
 $random\_generator$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="135" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img81.png"
 ALT="$random\_generator$"></SPAN> again, the same address can be taken by <SPAN CLASS="MATH"><IMG
 WIDTH="101" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img82.png"
 ALT="$print\_number$"></SPAN>. Possibly one can also rewrite the program as shown in figure fig:example:memory:overlay.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:example:memory:overlay"></A><A NAME="1108"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.4:</STRONG>
An example of memory overlay</CAPTION>
<TR><TD><IMG
 WIDTH="1189" HEIGHT="20" BORDER="0"
 SRC="img83.png"
 ALT="\begin{figure}\centering
\tikzstyle{module}=[draw, text centered, minimum heigh...
...int_number,
number);
...
}
\end{lstlisting}};
\end{tikzpicture}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
As we can see function <!-- MATH
 $overlay\_and\_call$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="121" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img84.png"
 ALT="$overlay\_and\_call$"></SPAN> takes a pointer to memory region, function pointer and variable number of argument to be supplied to the called function. When the function executed, instructions of function, whose pointer is supplied as parameter, are brought to specific region of the memory mentioned in the argument. This avoids any memory write backs and provides faster processing. Also this reduces the amount of memory required for applications [<A
 HREF="report.html#verma2004dynamic">42</A>].

<P>
We added support to handle memory overlays. For data overlay we treat each new memory overlay as new memory block allocation and old block as removal. The new instruction overlay and call to those instructions is treated as simple function call. This allows CBMC to handle memory overlays in simplest manner. In future work one can add support to verify the dangling pointers due to overlays.

<P>

<H2><A NAME="SECTION00832000000000000000">
Support for parallel programs</A>
</H2>

<P>
Parallel programs have several control flow paths and produce large formulas during model checking. The platform we analysed did not pose threat of state space explosion since processes are scheduled to reduce the concurrent processes accessing same data. Tasks created by a process are designed to operate on independent data block and process waits until all the task finish their job. Once all the tasks finish their operation, process collects the results. To handle this kind of parallelism we modified CBMC libraries to treat each task creation as function calls. When multiple tasks are created once, we call the task one by one and order of call does not affect result since each task works on independent data blocks.

<P>

<H2><A NAME="SECTION00833000000000000000">
Internal macros</A>
</H2>

<P>
The home grown compiler for the platform supports various internal macros. These macros are specific to compiler and platform. With these macros programmers can perform platform specific tasks. For example, Open-MP like macro can parallelise a loop over different hardware threads.

<P>

<P>

<H1><A NAME="SECTION00900000000000000000"></A> <A NAME="chapter:discussion"></A><BR>
Discussion and Conclusion
</H1>

<P>
During this thesis work we extend CBMC to handle features of DSP-C, provided a model to verify contract programming and proposed verification techniques to detect issues in Ericsson multicore DSP processor's parallel code.

<P>
In following sections we briefly discuss results of model checking performed on Ericsson's software. To begin with we used extended CBMC to check logical correctness of the code. In second step we performed contract verification. At last with collective knowledge of Ericsson's platform architecture and model checking on software, we proposed techniques to verify some more properties of the software.

<P>

<H2><A NAME="SECTION00901000000000000000">
Model checking</A>
</H2>
Test setup started with understanding Ericsson's build system, which is capable of handling large code base being maintained by large number of developers distributed across globe. The build system is complex to cater its requirements. Code base includes millions of lines of code and hundreds of developers working on it. For simplicity we started with modules which had little library dependency. Even with these modules we did have to port most of the Ericsson specific Real Time OS APIs. Also we should note that these libraries were already tested and deployed in products.

<P>
With the modified CBMC, API stubbing/porting and understanding of build system, we were able process libraries of Ericsson. During the test run we observed a lot of false positives on assertions since these assertions were written to handle run time errors. This we mainly attribute to the fact that existing code is not written to provide information to static analysers. As we understood in chapter chap:background and chap:implementation, static analysers work by looking at information available in the existing logic without knowing run time information. To make the best of any static analyser one has to provide run time information statically. This information can be provided as part of header in each module or function, commented information for analysers or through contracts. Code we were working had contracts and next section provides more details on contract based verification.

<P>
The source code we used for case study was LTE baseband controller software. Code was tested and deployed into products. Model checking process on 6 major modules took little over a month. Most of the time and effort was put to avoid false positives and state space explosion. State space explosion is still a major issue in model checking. With millions of lines of code we quite often had to choose small bounding values.

<P>

<P>

<H2><A NAME="SECTION00902000000000000000">
Contract verification</A>
</H2>
Most of the Ericsson code has contracts on function implementation. As we discussed in impl:contracts, we stubbed preconditions and postconditions with CBMC keywords. During Ericsson's code analysis we realised that contracts used in the code are run time guards, which is a way of pessimistically checking incoming parameters at run time. These conditions check values of each parameter when a function is called and return values are checked before returning. Contracts are not providing enough information to CBMC to verify the properties of each function. 

<P>
In verification, contracts are expected to be defined on behaviour of the function and also provide actual limits of parameter(s). Preconditions for the function can include limits on parameters and limits on global states. Postconditions can include affected states and results being returned. The affected states can be either part of parameters or global variables.

<P>

<H2><A NAME="SECTION00903000000000000000">
Identifying properties of thread local and concurrent threads</A>
</H2>

<P>
Apart from verifying logic properties of software, like arithmetic errors or pointer analysis, model checking can be used verify specific properties of the system. For example race conditions within a thread or between threads, memory handling or mutex handling. 

<P>
Thread local race conditions are seen in system where the processor core and processor peripheral access processor common memory asynchronously. For example a case study in [<A
 HREF="report.html#Donaldson:2011:AAD:2034876.2034900">15</A>] shows IBM cell processor with possible race condition between processor core and DMA controller. Ericsson platform uses a strong memory consistency model. During analysis we concluded that the DSP cores do not have thread local race conditions. Bounded model checking can verify some of thread local properties. For example:

<P>

<UL>
<LI><SPAN  CLASS="textbf">Correctness of memory allocation and deallocation</SPAN>

<P>
The dynamic memory management APIs can be instrumented to detect multiple deallocation of same memory address in a single thread.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Correctness of handling mutex variables</SPAN>

<P>
The mutex handling APIs can be instrumented to detect multiple locking/unlocking on same mutex variable.

<P>
</LI>
</UL>

<P>
As we discussed in earlier chapters, concurrent software have several control flow paths and produce large formulas during model checking. The platform we analysed is designed to operate on incoming signals. Typically multiple signal handlers run to completion on parallel cores. Majority of signal handler operations are independent of other signal handlers in the system. In some cases signal handlers share some resources. The signal handlers also take advantage of heterogeneous architecture and spawn threads to slave cores and accelerate the computation. Bounded model checking can be used to verify following properties of the platform.

<P>

<UL>
<LI><SPAN  CLASS="textbf">Verifying race conditions among the cores</SPAN>

<P>
In some cases signal handlers share resources, like shared data structures or shared IO devices. Bounded model checking can be used to identify possible race conditions.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Memory management</SPAN>

<P>
Signal handlers make use of slave cores and transfer some of the processing to slave cores. The slave cores are capable of accessing shared memory regions, allocate or deallocate memory. Bounded model checking can be used to verify correctness of the memory usage by multiple slave cores.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Correctness of using mutex variables</SPAN>

<P>
The shared memory access is done within protected area. We can instrument mutex APIs to detect possible unprotected access to shared memory regions.

<P>
</LI>
</UL>

<P>

<H1><A NAME="SECTION001000000000000000000">
Future Work</A>
</H1>

<P>
In current implementation we keep memory labels as variable properties in goto-programs. In future we can use these labels in verifying memory related operations.

<P>
As we discussed in previous sections, contracts defined in the code are not providing enough information to verifier. Ericsson's code can be carefully reviewed again and one can add contracts which provide enough information about functionality. Also, contracts can be defined effectively, through top down development approach. In top down development approach, product architecture is designed, architecture is divided into modules and each module will have specific functionality. This approach clearly identifies system states being used by each module. It is easier to identify possible preconditions, postcondition and invariants.

<P>
In previous chapter we have discussed various properties we identified in the system and proposed possible implementation techniques. All the properties can be verified by extending CBMC or instrumenting the software.

<P>

<P>
<BR>

<H2><A NAME="SECTION001100000000000000000">
Index</A>
</H2><DL COMPACT>
<DT><STRONG>__accum</STRONG>
<DD><A HREF="report.html#299">̣__accum types</A>
<DT><STRONG>__circ</STRONG>
<DD><A HREF="report.html#324">Circular buffers</A>
<DT><STRONG>__fixed</STRONG>
<DD><A HREF="report.html#283">̣__fixed types</A>
 | <A HREF="report.html#284">̣__fixed types</A>
<DT><STRONG>__sat</STRONG>
<DD><A HREF="report.html#315">Operations on new data</A>
<DT><STRONG>BDD</STRONG>
<DD><A HREF="report.html#538">Binary Decision Diagrams (BDDs)</A>
<DT><STRONG>CBMC</STRONG>
<DD><A HREF="report.html#373">CBMC</A>
<DT><STRONG>CFG</STRONG>
<DD><A HREF="report.html#173">Introduction</A>
<DT><STRONG>Contracts</STRONG>
<DD><A HREF="report.html#182">Contributions</A>
 | <A HREF="report.html#1055">Contract verification</A>
<DT><STRONG>DAG</STRONG>
<DD><A HREF="report.html#539">Binary Decision Diagrams (BDDs)</A>
<DT><STRONG>DSP</STRONG>
<DD><A HREF="report.html#178">Contributions</A>
<DT><STRONG>DSP-C</STRONG>
<DD><A HREF="report.html#269">DSP-C</A>
 | <A HREF="report.html#1050">DSP-C support</A>
<DT><STRONG>Full Adder</STRONG>
<DD><A HREF="report.html#501">Bit vector flattening</A>
 | <A HREF="report.html#501">Bit vector flattening</A>
<DT><STRONG>goto-program</STRONG>
<DD><A HREF="report.html#172">Introduction</A>
<DT><STRONG>LTE</STRONG>
<DD><A HREF="report.html#964">Ericsson hardware platform</A>
<DT><STRONG>SAT</STRONG>
<DD><A HREF="report.html#351">Satisfiability (SAT)</A>
<DT><STRONG>Satisfiability</STRONG>
<DD><A HREF="report.html#352">Satisfiability (SAT)</A>
<DT><STRONG>SSA</STRONG>
<DD><A HREF="report.html#175">Introduction</A>
 | <A HREF="report.html#444">Variable renaming</A>

</DL>

<P>

<H2><A NAME="SECTION001200000000000000000">
Bibliography</A>
</H2><DL COMPACT><DD><P></P><DT><A NAME="Apt:1981:TYH:357146.357150">1</A>
<DD>
K.R. Apt.
<BR>Ten years of hoare's logic: A survey - part i.
<BR><EM>ACM Transactions on Programming Languages and Systems (TOPLAS)</EM>,
  3(4):431-483, 1981.

<P></P><DT><A NAME="Balarin:1993:IAL:647762.735495">2</A>
<DD>
F.&nbsp;Balarin and A.&nbsp;Sangiovanni-Vincentelli.
<BR>An iterative approach to language containment.
<BR>In <EM>Computer Aided Verification</EM>, pages 29-40. Springer, 1993.

<P></P><DT><A NAME="biere2003bounded">3</A>
<DD>
A.&nbsp;Biere, A.&nbsp;Cimatti, E.M. Clarke, O.&nbsp;Strichman, and Y.&nbsp;Zhu.
<BR>Bounded model checking.
<BR><EM>Advances in computers</EM>, 58:117-148, 2003.

<P></P><DT><A NAME="brace1991efficient">4</A>
<DD>
K.S. Brace, R.L. Rudell, and R.E. Bryant.
<BR>Efficient implementation of a bdd package.
<BR>In <EM>Proceedings of the 27th ACM/IEEE design automation
  conference</EM>, pages 40-45. ACM, 1991.

<P></P><DT><A NAME="Bryant:1986:GAB:6432.6433">5</A>
<DD>
R.E. Bryant.
<BR>Graph-based algorithms for boolean function manipulation.
<BR><EM>Computers, IEEE Transactions on</EM>, 100(8):677-691, 1986.

<P></P><DT><A NAME="Burch90symbolicmodel">6</A>
<DD>
J.&nbsp;R. Burch, E.&nbsp;M. Clarke, K.&nbsp;L. Mcmillan, D.&nbsp;L. Dill, and L.&nbsp;J. Hwang.
<BR>Symbolic model checking: 10 20 states and beyond, 1990.

<P></P><DT><A NAME="clarke1997model">7</A>
<DD>
E.&nbsp;Clarke.
<BR>Model checking.
<BR>In <EM>Foundations of software technology and theoretical computer
  science</EM>, pages 54-56. Springer, 1997.

<P></P><DT><A NAME="clarke2008birth">8</A>
<DD>
E.&nbsp;Clarke.
<BR>The birth of model checking.
<BR><EM>25 Years of Model Checking</EM>, pages 1-26, 2008.

<P></P><DT><A NAME="springerlink:10.1007-3-540-44577-3-12">9</A>
<DD>
E.&nbsp;Clarke, O.&nbsp;Grumberg, S.&nbsp;Jha, Y.&nbsp;Lu, and H.&nbsp;Veith.
<BR>Progress on the state explosion problem in model checking.
<BR>In <EM>Informatics</EM>, pages 176-194. Springer, 2001.

<P></P><DT><A NAME="clarke2006ansi">10</A>
<DD>
E.&nbsp;Clarke and D.&nbsp;Kroening.
<BR>Ansi-c bounded model checker user manual.
<BR>Technical report, Technical report, School of Computer Science,
  Carnegie Mellon University, 2006.

<P></P><DT><A NAME="Clarke04atool">11</A>
<DD>
Edmund Clarke, Daniel Kroening, and Flavio Lerda.
<BR>A tool for checking ansi-c programs.
<BR>In <EM>In Tools and Algorithms for the Construction and Analysis of
  Systems</EM>, pages 168-176. Springer, 2004.

<P></P><DT><A NAME="clarke1996formal">12</A>
<DD>
E.M. Clarke and J.M. Wing.
<BR>Formal methods: State of the art and future directions.
<BR><EM>ACM Computing Surveys (CSUR)</EM>, 28(4):626-643, 1996.

<P></P><DT><A NAME="Davis:1962:MPT:368273.368557">13</A>
<DD>
M.&nbsp;Davis, G.&nbsp;Logemann, and D.&nbsp;Loveland.
<BR>A machine program for theorem-proving.
<BR><EM>Communications of the ACM</EM>, 5(7):394-397, 1962.

<P></P><DT><A NAME="DeMoura:2011:SMT:1995376.1995394">14</A>
<DD>
L.&nbsp;De&nbsp;Moura and N.&nbsp;Bj&#248;rner.
<BR>Satisfiability modulo theories: introduction and applications.
<BR><EM>Communications of the ACM</EM>, 54(9):69-77, 2011.

<P></P><DT><A NAME="Donaldson:2011:AAD:2034876.2034900">15</A>
<DD>
Alastair&nbsp;F. Donaldson, Daniel Kroening, and Philipp R&#252;mmer.
<BR>Automatic analysis of dma races using model checking and k-induction.
<BR><EM>Form. Methods Syst. Des.</EM>, 39(1):83-113, August 2011.

<P></P><DT><A NAME="website:dspc">16</A>
<DD>
DSP-C.
<BR>An extension to iso c.
<BR><TT><A NAME="tex2html22"
  HREF="http://www.dsp-c.org/">http://www.dsp-c.org/</A></TT>, May 2012.

<P></P><DT><A NAME="flynn1966very">17</A>
<DD>
M.J. Flynn.
<BR>Very high-speed computing systems.
<BR><EM>Proceedings of the IEEE</EM>, 54(12):1901-1909, 1966.

<P></P><DT><A NAME="godefroid2005software">18</A>
<DD>
P.&nbsp;Godefroid.
<BR>Software model checking: The verisoft approach.
<BR><EM>Formal Methods in System Design</EM>, 26(2):77-101, 2005.

<P></P><DT><A NAME="hagersten1992ddm">19</A>
<DD>
E.&nbsp;Hagersten, A.&nbsp;Landin, and S.&nbsp;Haridi.
<BR>Ddm-a cache-only memory architecture.
<BR><EM>Computer</EM>, 25(9):44-54, 1992.

<P></P><DT><A NAME="hall1990seven">20</A>
<DD>
A.&nbsp;Hall.
<BR>Seven myths of formal methods.
<BR><EM>Software, IEEE</EM>, 7(5):11-19, 1990.

<P></P><DT><A NAME="hennessy2011computer">21</A>
<DD>
J.L. Hennessy and D.A. Patterson.
<BR><EM>Computer architecture: a quantitative approach</EM>.
<BR>Morgan Kaufmann Pub, 2011.

<P></P><DT><A NAME="Hoare04communicatingsequential">22</A>
<DD>
C.&nbsp;A.&nbsp;R. Hoare.
<BR>Communicating sequential processes, 2004.

<P></P><DT><A NAME="Hoare03theverifying">23</A>
<DD>
Tony Hoare.
<BR>The verifying compiler: A grand challenge for computing research.
<BR><EM>Journal of the ACM</EM>, 50:2003, 2003.

<P></P><DT><A NAME="Kim_usinga">24</A>
<DD>
S.&nbsp;Kim, H.D. Patel, and S.A. Edwards.
<BR>Using a model checker to determine worst-case execution time.
<BR>Technical report, Citeseer, 2009.

<P></P><DT><A NAME="kroening2008decision">25</A>
<DD>
D.&nbsp;Kroening and O.&nbsp;Strichman.
<BR><EM>Decision procedures: an algorithmic point of view</EM>.
<BR>Springer-Verlag New York Inc, 2008.

<P></P><DT><A NAME="website:cprover:cbmc:applications">26</A>
<DD>
Daniel Kroening.
<BR>The cbmc applications.
<BR><TT><A NAME="tex2html23"
  HREF="http://www.cprover.org/cbmc/applications.shtml">http://www.cprover.org/cbmc/applications.shtml</A></TT>, May 2012.

<P></P><DT><A NAME="website:cprover:cbmc">27</A>
<DD>
Daniel Kroening.
<BR>The cbmc homepage.
<BR><TT><A NAME="tex2html24"
  HREF="http://www.cprover.org/cbmc/">http://www.cprover.org/cbmc/</A></TT>, May 2012.

<P></P><DT><A NAME="3540741046">28</A>
<DD>
Daniel Kroening and Ofer Strichman.
<BR><EM>Decision Procedures: An Algorithmic Point of View (Texts in
  Theoretical Computer Science. An EATCS Series)</EM>.
<BR>Springer, 2008.

<P></P><DT><A NAME="Malik:2009:BST:1536616.1536637">29</A>
<DD>
S.&nbsp;Malik and L.&nbsp;Zhang.
<BR>Boolean satisfiability from theoretical hardness to practical
  success.
<BR><EM>Communications of the ACM</EM>, 52(8):76-82, 2009.

<P></P><DT><A NAME="Meyer:1992:ADC:618974.619797">30</A>
<DD>
Bertrand Meyer.
<BR>Applying "design by contract".
<BR><EM>Computer</EM>, 25(10):40-51, October 1992.

<P></P><DT><A NAME="moskewicz2001chaff">31</A>
<DD>
M.W. Moskewicz, C.F. Madigan, Y.&nbsp;Zhao, L.&nbsp;Zhang, and S.&nbsp;Malik.
<BR>Chaff: Engineering an efficient sat solver.
<BR>In <EM>Proceedings of the 38th annual Design Automation Conference</EM>,
  pages 530-535. ACM, 2001.

<P></P><DT><A NAME="overton2001numerical">32</A>
<DD>
M.L. Overton.
<BR><EM>Numerical computing with IEEE floating point arithmetic</EM>.
<BR>Siam, 2001.

<P></P><DT><A NAME="Pixley:1992:ECS:113938.149645">33</A>
<DD>
C.&nbsp;Pixley, S.W. Jeong, and G.D. Hachtel.
<BR>Exact calculation of synchronizing sequences based on binary decision
  diagrams.
<BR><EM>Computer-Aided Design of Integrated Circuits and Systems, IEEE
  Transactions on</EM>, 13(8):1024-1034, 1994.

<P></P><DT><A NAME="post2007integrated">34</A>
<DD>
H.&nbsp;Post and W.&nbsp;K&#252;chlin.
<BR>Integrated static analysis for linux device driver verification.
<BR>In <EM>Integrated Formal Methods</EM>, pages 518-537. Springer, 2007.

<P></P><DT><A NAME="Rabinovitz05boundedmodel">35</A>
<DD>
Ishai Rabinovitz and Orna Grumberg.
<BR>Bounded model checking of concurrent programs.
<BR>In <EM>In Computer-Aided Verification (CAV), LNCS 3576</EM>, pages
  82-97. Springer, 2005.

<P></P><DT><A NAME="dspcbenifits">36</A>
<DD>
M.&nbsp;Roodzant.
<BR>Real-time dsp applications benefit from high-level language
  compilation.
<BR><EM>REAL TIME MAGAZINE</EM>, page&nbsp;40, 1999.

<P></P><DT><A NAME="website:dspc:specification">37</A>
<DD>
DSP-C Speification.
<BR>An extension to iso c.
<BR><TT><A NAME="tex2html25"
  HREF="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n854.pdf">http://www.open-std.org/JTC1/SC22/WG14/www/docs/n854.pdf</A></TT>, May
  2012.

<P></P><DT><A NAME="Staats:2008:PTV:1482985.1483006">38</A>
<DD>
M.&nbsp;Staats and M.&nbsp;Heimdahl.
<BR>Partial translation verification for untrusted code-generators.
<BR><EM>Formal Methods and Software Engineering</EM>, pages 226-237, 2008.

<P></P><DT><A NAME="tiwari1995power">39</A>
<DD>
V.&nbsp;Tiwari and M.&nbsp;Tien-Chien&nbsp;Lee.
<BR>Power analysis of a 32-bit embedded microcontroller.
<BR>In <EM>Design Automation Conference, 1995. Proceedings of the
  ASP-DAC'95/CHDL'95/VLSI'95., IFIP International Conference on Hardware
  Description Languages; IFIP International Conference on Very Large Scale
  Integration., Asian and South Pacific</EM>, pages 141-148. IEEE, 1995.

<P></P><DT><A NAME="VardiW86">40</A>
<DD>
Moshe&nbsp;Y. Vardi and Pierre Wolper.
<BR>An automata-theoretic approach to automatic program verification
  (preliminary report).
<BR>In <EM>LICS</EM>, pages 332-344, 1986.

<P></P><DT><A NAME="vasudevan2008static">41</A>
<DD>
N.&nbsp;Vasudevan and S.A. Edwards.
<BR>Static deadlock detection for the shim concurrent language.
<BR>In <EM>Formal Methods and Models for Co-Design, 2008. MEMOCODE 2008.
  6th ACM/IEEE International Conference on</EM>, pages 49-58. IEEE, 2008.

<P></P><DT><A NAME="verma2004dynamic">42</A>
<DD>
M.&nbsp;Verma, L.&nbsp;Wehmeyer, and P.&nbsp;Marwedel.
<BR>Dynamic overlay of scratchpad memory for energy minimization.
<BR>In <EM>Proceedings of the 2nd IEEE/ACM/IFIP international conference
  on Hardware/software codesign and system synthesis</EM>, pages 104-109. ACM,
  2004.

<P></P><DT><A NAME="springerlink:10.1007_978-3-540-88479-8_30">43</A>
<DD>
I.&nbsp;Wenzel, R.&nbsp;Kirner, B.&nbsp;Rieder, and P.&nbsp;Puschner.
<BR>Measurement-based timing analysis.
<BR><EM>Leveraging Applications of Formal Methods, Verification and
  Validation</EM>, pages 430-444, 2009.

<P></P><DT><A NAME="werner2010correctness">44</A>
<DD>
F.&nbsp;Werner and D.&nbsp;Farag&#243;.
<BR>Correctness of sensor network applications by software bounded model
  checking.
<BR><EM>Formal Methods for Industrial Critical Systems</EM>, pages 115-131,
  2010.

<P></P><DT><A NAME="zhu1997software">45</A>
<DD>
H.&nbsp;Zhu, P.A.V. Hall, and J.H.R. May.
<BR>Software unit test coverage and adequacy.
<BR><EM>ACM Computing Surveys (CSUR)</EM>, 29(4):366-427, 1997.
</DL>

<P>

<H1><A NAME="SECTION001300000000000000000"></A> <A NAME="appendix:a"></A><BR>
Examples of new data type and verification results
</H1>

<P>
Below program presents a example of __fixed type.

<P>
<BR>
<IMG
 WIDTH="262" HEIGHT="130" ALIGN="BOTTOM" BORDER="0"
 SRC="img85.png"
 ALT="\begin{lstlisting}
int main() {
short __fixed a = 0.001r;
__fixed b = 0.01r;
\par
if(a + b &gt; 0.01r)
assert(0);
}
\end{lstlisting}">
<BR>

<P>
As we can see from above program assertion will be true, same has been detected using CBCM on static analysis and given a trace of it.

<P>
<BR>
<IMG
 WIDTH="676" HEIGHT="1181" ALIGN="BOTTOM" BORDER="0"
 SRC="img86.png"
 ALT="\begin{lstlisting}
file ./fixed_type.c: Parsing
Converting
Type-checking fixed_t...
...
file ./fixed_type.c line 7 function main
assertion
(_Bool)0
\end{lstlisting}">
<BR>

<P>
Below program presents a example of __accum type.

<P>
<BR>
<IMG
 WIDTH="262" HEIGHT="130" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.png"
 ALT="\begin{lstlisting}
int main() {
short __accum a = 0.001a;
__accum b = 1.01a;
\par
if(a + b &gt; 1.01a)
assert(0);
}
\end{lstlisting}">
<BR>

<P>
As we can see from above program assertion will be true, same has been detected using CBCM on static analysis and given a trace of it.

<P>
<BR>
<IMG
 WIDTH="752" HEIGHT="1238" ALIGN="BOTTOM" BORDER="0"
 SRC="img88.png"
 ALT="\begin{lstlisting}
file ./fixed_type.c: Parsing
Converting
Type-checking fixed_t...
...
VERIFICATION FAILED
Error[10]: while processing ./fixed_type.c
\end{lstlisting}">
<BR>

<P>

<H1><A NAME="SECTION001400000000000000000"></A> <A NAME="appendix:b"></A><BR>
Contract verification example
</H1>

<P>
Consider a faulty implementation of open door where the door may not be opened even though preconditions are met.

<P>
<BR>
<IMG
 WIDTH="577" HEIGHT="417" ALIGN="BOTTOM" BORDER="0"
 SRC="img89.png"
 ALT="\begin{lstlisting}
/**
* @function: open_door
* This function automatically op...
...door_open=false;
\par
postcondition (door_open == true);
}
\par
\end{lstlisting}">
<BR>

<P>
The CBMC verifies for the postcondtion and suggests possible states which can lead to failure.

<P>
<BR>
<IMG
 WIDTH="781" HEIGHT="2230" ALIGN="BOTTOM" BORDER="0"
 SRC="img90.png"
 ALT="\begin{lstlisting}
file contract.cpp: Parsing
Converting
Type-checking contract
...
... 21
assertion
door_open == TRUE
\par
VERIFICATION FAILED
\par
\end{lstlisting}">
<BR>

<P>

<H1><A NAME="SECTION001500000000000000000">
About this document ...</A>
</H1>
 <STRONG>Model checking of multicore software using CBMC</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2008 (1.71)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
Nikos Drakos, 
Computer Based Learning Unit, University of Leeds.
<BR>Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-no_navigation -split 0 report.tex</TT>
<P>
The translation was initiated by ash on 2012-10-01<BR><HR>
<ADDRESS>
ash
2012-10-01
</ADDRESS>
</BODY>
</HTML>
